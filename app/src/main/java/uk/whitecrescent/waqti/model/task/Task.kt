package uk.whitecrescent.waqti.model.task

import io.reactivex.Observable
import io.reactivex.disposables.CompositeDisposable
import io.reactivex.schedulers.Schedulers
import uk.whitecrescent.waqti.model.Cacheable
import uk.whitecrescent.waqti.model.Duration
import uk.whitecrescent.waqti.model.Listable
import uk.whitecrescent.waqti.model.Time
import uk.whitecrescent.waqti.model.ids
import uk.whitecrescent.waqti.model.now
import uk.whitecrescent.waqti.model.persistence.Caches
import uk.whitecrescent.waqti.model.tasks

// TODO: 18-Jun-18 When done, make sure everything is tested and doc'd
class Task(var title: String = "") : Listable, Cacheable {

    //region Class Properties

    /**
     * A Long value representing an ID for a Task.
     * Every Task has a unique identifier which is generated by means of pseudo-random number designation.
     * No 2 Tasks can have the same taskID, all taskIDs are positive Long values generated randomly.
     * The list of all currently used IDs should be stored persistently.
     * @see java.util.Random.nextLong
     */
    override val id = Caches.tasks.newID()

    init {
        Caches.tasks.put(this)
        checkNotDead()
    }

    /**
     * The Task State is the state in which the task is in at this point in time.
     * By default this is initialized to EXISTING.
     * The Task State changes according to Lifecycle changes such as [sleep], [kill], [fail],
     * such changes can also occur due to Constraints.
     * See The Task Lifecycle Documentation for more information
     * @see TaskState
     */
    var state = DEFAULT_TASK_STATE
        private set

    /**
     * Boolean value representing whether it is possible for this Task to be failed at any arbitrary point in time.
     * Note that this is not the same as whether it can be failed right now, however if a Task's `isFailable`
     * is `false` then it can not be failed at this point in time.
     * @see TaskState
     * @see Constraint
     */
    var isFailable = DEFAULT_FAILABLE

    /**
     * Boolean value representing whether it is possible for this Task to be killed at any arbitrary point in time.
     * Note that this is not the same as whether it can be killed right now, however if a Task's `isKillable`
     * is `false` then it can not be killed at this point in time.
     * @see TaskState
     */
    var isKillable = DEFAULT_KILLABLE

    // A Task ages when it is failed
    var age = 0
        private set

    // The times a task has been failed
    val failedTimes = arrayListOf<Time>()

    // The time a task is killed
    var killedTime = DEFAULT_TIME
        private set

    // Used for Duration Constraint
    private val timer = Timer()

    // Used to compile all Observables
    private val composite = CompositeDisposable()

    /**
     * Used to determine the overall state of this Task at this point in time.
     *
     * This is especially useful for [Task.hashCode] and [Task.equals] hence the implementation does not contain as
     * many aspects of this Task as it could.
     *
     * A Task's Equality Bundle is determined by the following:
     *
     * * [title]
     * * [state]
     * * [isFailable]
     * * [isKillable]
     * * [age]
     * * [failedTimes]
     * * [killedTime]
     * * [getAllProperties], the list of this Task's Properties.
     *
     * For [getAllProperties] see [java.util.ArrayList.equals], essentially all Properties must be equal in order for
     * this to be satisfied see [Property.equals] meaning even the values must be equal, this will differ depending
     * on the type of value, for example any [Time] is equal to another if and only if they are exactly the
     * same to the nanosecond precision see [Time.equals] whereas [StringBuilder] checks for equality using
     * identity meaning two different StringBuilder instances can have the exact same value and be consider unequal
     * see [java.lang.StringBuilder] (it does not override equals, hence this default implementation)
     *
     * @see HashMap
     * @return a HashMap with `String` as the Key and `Any` as the Value to represent the Equality Bundle which will
     * store the parts that make up a Task's overall state
     */
    private fun equalityBundle(): HashMap<String, Any> {
        val bundle = HashMap<String, Any>(8)
        bundle["title"] = this.title
        bundle["state"] = this.state
        bundle["isFailable"] = this.isFailable
        bundle["isKillable"] = this.isKillable
        bundle["age"] = this.age
        bundle["failedTimes"] = this.failedTimes
        bundle["killedTime"] = this.killedTime
        bundle["properties"] = this.getAllProperties()
        return bundle
    }

    //endregion Class Properties

    //region Task Properties

    // TODO: 23-Jun-18 Change the Properties with ArrayList's to take in Collections in their set methods

    // TODO: 23-Jun-18 Should we change the ArrayLists to be Lists??

    /**
     * The point in natural time after which this Task will be relevant, this can also be referred to as scheduled
     * time.
     *
     * If time is a Constraint then the Task cannot be killed until after that time
     * and is in the SLEEPING state during that period, however, if time is not a Constraint then the Task can be
     * killed freely and will be in its previous state meaning no lifecycle change will be made. If time is a
     * Property then it has no rules on killing the Task.
     *
     * @see Time
     */
    var time: Property<Time> = DEFAULT_TIME_PROPERTY
        private set

    /**
     * The estimated amount of time that this Task will take, this can also be referred to as minimum duration.
     *
     * This is defined in any Time Measurement Unit, either as a standard Time Unit such as seconds or days etc or
     * custom Time Units [TimeUnit]. This can also be referred to as minimum duration. If duration is a Constraint
     * then the Task cannot be killed in the midst of the duration, it can be killed only after it has ended. If
     * duration is a Property then it has no rules on killing the Task.
     *
     * @see Duration
     * @see TimeUnit
     */
    var duration: Property<Duration> = DEFAULT_DURATION_PROPERTY
        private set

    /**
     * The user defined level of importance of a Task represented as a String with a number representing importance
     * level.
     *
     * Priority is particularly useful in solving or mediating Task collisions within collections. A Task collision
     * occurs when two or more Tasks in a collection share the same time, if they have different priority levels then
     * the Task with the higher priority level will be shown and a collision warning will be displayed to the user,
     * this is called a weak collision. If the tasks have equal priority levels then the user must mediate or solve
     * the collision themselves, this is called a strong collision.
     *
     * Priority can not be a Constraint.
     *
     * @see Priority
     */
    var priority: Property<Priority> = DEFAULT_PRIORITY_PROPERTY
        private set

    /**
     * The user defined category(s) that this Task belongs to.
     *
     * A Task can belong to or have 0 or many labels. Labels are used as a way of categorizing Tasks and are thus
     * helpful in filtering and analytics.
     *
     * Labels can not be a Constraint.
     *
     * @see ArrayList
     * @see Label
     */
    var labels: Property<ArrayList<Label>> = DEFAULT_LABELS_PROPERTY
        private set

    /**
     * Shows whether the Task is optional or not.
     *
     * An optional Task is one that is to be done or pursued if there is free time, thus an optional Task has less
     * priority than a non-optional Task (mandatory Task) even if the Task has the lowest priority, this makes
     * optional Tasks the lowest priority of all Tasks. In many ways the optional Property acts similar to the priority
     * Property except in that optional is lower priority than the lowest priority.
     *
     * Optional can not be a Constraint.
     *
     * @see Boolean
     */
    var optional: Property<Optional> = DEFAULT_OPTIONAL_PROPERTY
        private set

    /**
     * A textual description of this Task, useful for if the Task is complex or requires further information that the
     * title cannot provide.
     *
     * Description can not be a Constraint.
     *
     * @see StringBuilder
     */
    var description: Property<Description> = DEFAULT_DESCRIPTION_PROPERTY
        private set

    /**
     * A list of checkable items that this Task may have.
     *
     * This is useful if the Task can be broken down into smaller chunks which can be represented as list items in a
     * checklist. Items in a checklist can be checked or deleted.
     *
     * If a checklist is a Constraint then the Task cannot be killed unless every item in the checklist is checked,
     * more specifically the checklist has no unchecked items. An empty checklist has no unchecked items so it is
     * important that the implementation be aware of this and differentiate between an empty checklist (which is
     * possible for good reasons) and a checklist with all its items checked.
     *
     * If checklist is a Property then it has no rules on killing the Task.
     *
     * @see Checklist
     * @see ListItem
     */
    var checklist: Property<Checklist> = DEFAULT_CHECKLIST_PROPERTY
        private set

    /**
     * The point in natural time after which this Task can no longer be killed and thus is FAILED.
     *
     * If deadline is a Constraint then after the deadline time passes plus the grace period [GRACE_PERIOD] the Task will be
     * FAILED and thus no longer can be KILLED.
     *
     * If deadline is a Property it has no rules on failing or killing the Task.
     *
     * @see Time
     * @see GRACE_PERIOD
     */
    var deadline: Property<Time> = DEFAULT_DEADLINE_PROPERTY
        private set

    /**
     * The user defined textual representation of a desirable target to be achieved by the user before killing this
     * Task.
     *
     * If target is a Constraint then the Task cannot be killed unless the Target is checked. If target is a Property
     * then it has no rules on killing the Task and acts very similar to a description.
     *
     * @see String
     */
    var target: Property<Target> = DEFAULT_TARGET_PROPERTY
        private set

    /**
     * The Task that occurs before this Task.
     *
     * If before is a Constraint then this Task cannot be killed unless the before Task is killed, and if the before
     * Task is FAILED then this Task will also be FAILED if it can be since this Task will have a dependence on the
     * state of the before Task.
     *
     * If before is a Property then it has no rules on killing or failing the Task, it will just be a description of
     * the Task that comes before this one, good for ordering Tasks but not enforcing any ordering of completion.
     *
     * @see Long
     */
    var before: Property<ID> = DEFAULT_BEFORE_PROPERTY
        private set

    /**
     * The list of sub-Tasks this Task has, a Task can have zero to potentially many sub-Tasks but has zero by
     * default.
     *
     * If SubTasks is a Constraint then the state of the sub-Tasks is shared upwards to the parent, meaning
     * if this Task's sub-Tasks contains a FAILED Task then this Task is FAILED, if this Task's sub-Tasks contains a
     * non-killed non-optional Task then this Task cannot be killed, only if all the sub-Tasks are KILLED will the
     * Constraint be met.
     *
     * If SubTasks is a Property then it has no rules on killing or failing the Task, the sub-Tasks' states will make
     * no difference to this Task.
     *
     * @see ArrayList
     * @see Long
     */
    var subTasks: Property<ArrayList<ID>> = DEFAULT_SUB_TASKS_PROPERTY
        private set

    //endregion Task Properties

    //region Task Properties Functions

    /**
     * Makes this Task failable if the passed in Property is a Constraint and this Task is not currently failable.
     * @see Property
     * @see Constraint
     * @see isFailable
     * @param property the Property to check for if it is a Constraint
     */
    private fun makeFailableIfConstraint(property: Property<*>) {
        if (!this.isFailable && property is Constraint) {
            this.isFailable = true
        }
    }

    private fun makeNonFailableIfNoConstraints() {
        if (this.getAllConstraints().isEmpty()) this.isFailable = false
    }

    /**
     * Gets the list of all the Properties of a Task, does not matter what their values are.
     * See the Properties.md docs for more.
     * @return the list of all the Properties of a Task.
     */
    private fun getAllProperties() = listOf(
            time,
            duration,
            priority,
            labels,
            optional,
            description,
            checklist,
            deadline,
            target,
            before,
            subTasks
    )

    fun unConstrainAll(): Task {
        if (time is Constraint) time = time.asConstraint.toProperty()
        if (duration is Constraint) duration = duration.asConstraint.toProperty()
        if (priority is Constraint) priority = priority.asConstraint.toProperty()
        if (labels is Constraint) labels = labels.asConstraint.toProperty()
        if (optional is Constraint) optional = optional.asConstraint.toProperty()
        if (description is Constraint) description = description.asConstraint.toProperty()
        if (checklist is Constraint) checklist = checklist.asConstraint.toProperty()
        if (deadline is Constraint) deadline = deadline.asConstraint.toProperty()
        if (target is Constraint) target = target.asConstraint.toProperty()
        if (before is Constraint) before = before.asConstraint.toProperty()
        if (subTasks is Constraint) subTasks = subTasks.asConstraint.toProperty()
        return this
    }

    /**
     * Gets the list of all Constraints of this Task, does not matter what their values are as long as they are
     * Constraints.
     * @return the list of all current Constraints of this Task
     */
    private fun getAllConstraints() =
            getAllProperties().filter { it is Constraint }

    /**
     * Gets the list of all Properties of this Task that are showing. These would usually be the Properties of
     * interest.
     * @see Property
     * @return the list of all showing Properties this Task has
     */
    fun getAllShowingProperties() =
            getAllProperties().filter { it.isVisible }

    /**
     * Gets the list of all Constraints of this Task that are showing. The `isMet` value of the Constraints is ignored.
     * @see Constraint
     * @return the list of all showing Constraints this Task has
     */
    fun getAllShowingConstraints() =
            getAllConstraints().filter { it.isVisible }

    /**
     * Gets the list of all Constraints of this Task that are showing and also unmet. These would usually be the
     * Constraints of interest and the Constraints that would prevent a Task from being killed.
     * A Task can only be killed if this list is empty.
     * @see Constraint
     * @see canKill
     * @see kill
     * @return the list of all showing and unmet Constraints this Task has
     */
    fun getAllUnmetAndShowingConstraints() =
            getAllConstraints().filter { !(it as Constraint).isMet && it.isVisible }

    //endregion Task Properties Functions

    //region Property setters for chaining

    //region Time

    /**
     * Sets this Task's time Property, the passed in Property can be a Constraint.
     *
     * Further changes will occur only if the passed in `timeProperty` is after now and it is a Constraint, otherwise
     * no more changes will occur.
     *
     * In the case that the passed in `timeProperty` is a Constraint and it is after now, three things will happen:
     *
     * * This Task's state will become SLEEPING
     * * This Task will become failable if it wasn't already
     * * This Task will start checking the time, and will become EXISTING once the time in `timeProperty` has passed
     * and will also make the time Constraint MET if it wasn't already see [timeConstraintTimeChecking]
     *
     * If the passed in `timeProperty` is not a Constraint or is not after now then the Task's state will remain the
     * same.
     *
     * @see Task.timeConstraintTimeChecking
     * @param timeProperty the `Property` of type `Time` that this Task's time will be set to
     * @return this Task after setting the Task's time Property
     */
    fun setTimeProperty(timeProperty: Property<Time>): Task {
        this.time = timeProperty
        if (timeProperty is Constraint) {
            if (timeProperty.value.isAfter(now)) {
                if (canSleep()) sleep()
                makeFailableIfConstraint(timeProperty)
            }
            timeConstraintTimeChecking()
        }
        update()
        return this
    }

    /**
     * Sets this Task's time Constraint.
     *
     * @see Task.setTimeProperty
     * @param timeConstraint the `Constraint` of type `Time` that this Task's time will be set to
     * @return this Task after setting the Task's time Constraint
     */
    fun setTimeConstraint(timeConstraint: Constraint<Time>) = setTimeProperty(timeConstraint)

    /**
     * Sets this Task's time Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setTimeProperty(Property(SHOWING, myTime))`.
     *
     * @see Task.setTimeProperty
     * @param time the Time value that this Task's time value will be set to
     * @return this Task after setting the Task's time Property
     */
    fun setTimePropertyValue(time: Time) = setTimeProperty(Property(SHOWING, time))

    /**
     * Sets this Task's time Constraint with the given value and makes the Constraint showing and unmet.
     *
     * This is a shorthand of writing `setTimeConstraint(Constraint(SHOWING, myTime, UNMET))`.
     *
     * @see Task.setTimeProperty
     * @param time the Time value that this Task's time value will be set to
     * @return this Task after setting the Task's time Constraint
     */
    fun setTimeConstraintValue(time: Time) = setTimeProperty(Constraint(SHOWING, time, UNMET))

    //endregion Time

    //region Duration

    /**
     * Sets this Task's duration Property, the passed in Property can be a Constraint.
     *
     * Further changes will occur only if the passed in `durationProperty` is a Constraint.
     *
     * In the case that the passed in `durationProperty` is a Constraint, two things will happen:
     *
     * * This Task will become failable if it wasn't already
     * * This Task will start checking the time and after the duration has passed will make the duration
     * Constraint MET if it wasn't already see [durationConstraintTimeChecking]
     *
     * If the passed in `durationProperty` is not a Constraint then the Task's state will remain the same.
     *
     * @see Task.durationConstraintTimeChecking
     * @param durationProperty the `Property` of type `java.time.Duration` that this Task's duration will be set to
     * @return this Task after setting the Task's duration Property
     */
    fun setDurationProperty(durationProperty: Property<Duration>): Task {
        this.duration = durationProperty
        if (durationProperty is Constraint) {
            makeFailableIfConstraint(durationProperty)
        }
        update()
        return this
    }

    /**
     * Gets this Task's duration left until the duration Constraint will be met.
     *
     * This is not necessarily only used for Constraints but is more useful for when duration is a Constraint, since
     * this will return the difference in time between now and the time the duration is due to finish, this does not
     * require duration to be a Constraint but is of not much interest if duration is not a Constraint.
     *
     * @return the Duration left until this Task's duration Constraint is met
     * @throws TaskException if the Duration has not been set
     */
    fun getDurationLeft(): Duration {
        if (duration.value == DEFAULT_DURATION) {
            throw TaskException("Duration not set!")
        } else {
            return duration.value.minus(timer.duration)
        }
    }

    /**
     * Sets this Task's duration Constraint.
     *
     * @see Task.setDurationProperty
     * @param durationConstraint the `Constraint` of type `java.time.Duration` that this Task's duration will be set to
     * @return this Task after setting the Task's duration Constraint
     */
    fun setDurationConstraint(durationConstraint: Constraint<Duration>) = setDurationProperty(durationConstraint)

    /**
     * Sets this Task's duration Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setDurationProperty(Property(SHOWING, myDuration))`.
     *
     * @see Task.setDurationProperty
     * @param duration the java.time.Duration value that this Task's duration value will be set to
     * @return this Task after setting the Task's duration Property
     */
    fun setDurationPropertyValue(duration: Duration) = setDurationProperty(Property(SHOWING, duration))

    /**
     * Sets this Task's duration Constraint with the given value and makes the Constraint showing and unmet.
     *
     * This is a shorthand of writing `setDurationConstraint(Constraint(SHOWING, myDuration, UNMET))`.
     *
     * @see Task.setDurationProperty
     * @param duration the java.time.Duration value that this Task's duration value will be set to
     * @return this Task after setting the Task's duration Constraint
     */
    fun setDurationConstraintValue(duration: Duration) = setDurationProperty(Constraint(SHOWING, duration, UNMET))

    /**
     * Sets this Task's duration Property with the duration of the TimeUnit multiplied by the `count` as the Property's
     * value and the `timeUnitProperty`'s `isVisible` value
     *
     * This allows to use Custom Time Units for setting the duration.
     *
     * @see Task.setDurationProperty
     * @see TimeUnit
     * @param timeUnitProperty the Property of type `TimeUnit` that will be used to set this Task's duration
     * Property's visibility to and set the value to by multiplying by the `count`
     * @param count the number of times the `TimeUnit` occurs
     * @return this Task after setting the Task's duration Property
     */
    fun setDurationPropertyTimeUnits(timeUnitProperty: Property<TimeUnit>, count: Int): Task {
        val duration = TimeUnit.toJavaDuration(timeUnitProperty.value, count)
        if (timeUnitProperty is Constraint) {
            setDurationProperty(Constraint(timeUnitProperty.isVisible, duration, UNMET))
        } else {
            setDurationProperty(Property(timeUnitProperty.isVisible, duration))
        }
        return this
    }

    /**
     * Sets this Task's duration Constraint with the duration of the TimeUnit multiplied by the `count` as the
     * Constraint's value and the `timeUnitConstraint`'s Constraint values for this Task's duration Constraint values.
     *
     * This allows to use Custom Time Units for setting the duration.
     *
     * @see Task.setDurationProperty
     * @see TimeUnit
     * @param timeUnitConstraint the Constraint of type `TimeUnit` that will be used to set this Task's duration
     * Constraint's visibility to and set the value to by multiplying by the `count` and this Task's duration's
     * `isMet` value to
     * @param count the number of times the `TimeUnit` occurs
     * @return this Task after setting the Task's duration Constraint
     */
    fun setDurationConstraintTimeUnits(timeUnitConstraint: Constraint<TimeUnit>, count: Int): Task {
        val duration = TimeUnit.toJavaDuration(timeUnitConstraint.value, count)
        setDurationProperty(Constraint(timeUnitConstraint.isVisible, duration, timeUnitConstraint.isMet))
        return this
    }

    /**
     * Sets this Task's duration Property with the duration of the TimeUnit multiplied by the `count` as the Property's
     * value and makes the Property showing.
     *
     * This allows to use Custom Time Units for setting the duration and is shorthand for writing
     * `setDurationPropertyTimeUnits(Property(SHOWING, myTimeUnit), myCount)`
     *
     * @see Task.setDurationProperty
     * @see TimeUnit
     * @param timeUnit the TimeUnit that will be used to set this Task's duration to by multiplying it by the
     * `count`
     * @param count the number of times the `TimeUnit` occurs
     * @return this Task after setting the Task's duration Property
     */
    fun setDurationPropertyTimeUnitsValue(timeUnit: TimeUnit, count: Int) =
            setDurationProperty(Property(SHOWING, TimeUnit.toJavaDuration(timeUnit, count)))

    /**
     * Sets this Task's duration Constraint with the duration of the TimeUnit multiplied by the `count` as the
     * Constraints's value and makes the Constraint showing and unmet.
     *
     * This allows to use Custom Time Units for setting the duration and is shorthand for writing
     * `setDurationConstraintTimeUnits(Constraint(SHOWING, myTimeUnit, UNMET), myCount)`
     *
     * @see Task.setDurationProperty
     * @see TimeUnit
     * @param timeUnit the TimeUnit that will be used to set this Task's duration to by multiplying it by the
     * `count`
     * @param count the number of times the `TimeUnit` occurs
     * @return this Task after setting the Task's duration Constraint
     */
    fun setDurationConstraintTimeUnitsValue(timeUnit: TimeUnit, count: Int) =
            setDurationProperty(Constraint(SHOWING, TimeUnit.toJavaDuration(timeUnit, count), UNMET))

    //endregion Duration

    //region Priority

    /**
     * Sets this Task's priority Property.
     *
     * Priority is non-constrain-able and so if a Constraint is passed in it will be ignored as a Constraint and it's
     * `isVisible` and `value` values will be used to set a Property for priority.
     *
     * @see Priority
     * @param priorityProperty the `Property` of type `Priority` that this Task's priority will be set to
     * @return this Task after setting the Task's priority Property
     */
    fun setPriorityProperty(priorityProperty: Property<Priority>): Task {
        this.priority = Property(priorityProperty.isVisible, priorityProperty.value)
        update()
        return this
    }

    /**
     * Sets this Task's priority Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setPriorityProperty(Property(SHOWING, myPriority))`.
     *
     * @see Task.setPriorityProperty
     * @param priority the Priority value that this Task's priority value will be set to
     * @return this Task after setting the Task's priority Property
     */
    fun setPriorityValue(priority: Priority) = setPriorityProperty(Property(SHOWING, priority))

    //endregion Priority

    //region Labels

    /**
     * Sets this Task's labels Property.
     *
     * Label is non-constrain-able and so if a Constraint is passed in it will be ignored as a Constraint and it's
     * `isVisible` and `value` values will be used to set a Property for labels.
     *
     * @see Label
     * @param labelProperty the `Property` containing the list of all labels that this Task's labels property will be
     * set to
     * @return this Task after setting the Task's labels Property
     */
    fun setLabelsProperty(labelProperty: Property<ArrayList<Label>>): Task {
        this.labels = Property(labelProperty.isVisible, labelProperty.value)
        update()
        return this
    }

    /**
     * Sets this Task's labels Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setLabelsProperty(Property(SHOWING, myLabelList))`.
     *
     * @see Task.setLabelsProperty
     * @param labels the list of labels that this Task's labels Property will be set to
     * @return this Task after setting the Task's labels Property
     */
    fun setLabelsValue(vararg labels: Label) = setLabelsProperty(Property(SHOWING, arrayListOf(*labels)))

    /**
     * Adds the passed in labels to this Task's labels Property and makes this Task's labels Property showing if it
     * wasn't already.
     *
     * @see Label
     * @param labels the labels to add to this Task's labels Property
     * @return this Task after adding the labels to the Task's labels Property
     */
    fun addLabels(vararg labels: Label): Task {
        if (!this.labels.isVisible) {
            this.labels.isVisible = SHOWING
        }
        this.labels.value.addAll(labels)
        update()
        return this
    }

    /**
     * Removes a label from this Task's labels Property.
     *
     * @see Label
     * @param label the label to remove from this Task's labels Property
     * @return this Task after removing the label from the Task's labels Property
     */
    fun removeLabel(label: Label): Task {
        this.labels.value.remove(label)
        update()
        return this
    }

    //endregion Labels

    //region Optional

    /**
     * Sets this Task's optional Property.
     *
     * Optional is non-constrain-able and so if a Constraint is passed in it will be ignored as a Constraint and it's
     * `isVisible` and `value` values will be used to set a Property for optional.
     *
     * @param optionalProperty the `Property` of type `Optional` that this Task's optional will be set to
     * @return this Task after setting the Task's optional Property
     */
    fun setOptionalProperty(optionalProperty: Property<Optional>): Task {
        this.optional = Property(optionalProperty.isVisible, optionalProperty.value)
        update()
        return this
    }

    /**
     * Sets this Task's optional Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setOptionalProperty(Property(SHOWING, myOptional))`.
     *
     * @see Task.setOptionalProperty
     * @param optional the Optional value that this Task's optional value will be set to
     * @return this Task after setting the Task's optional Property
     */
    fun setOptionalValue(optional: Optional) = setOptionalProperty(Property(SHOWING, optional))

    //endregion Optional

    //region Description

    /**
     * Sets this Task's description Property.
     *
     * Description is non-constrain-able and so if a Constraint is passed in it will be ignored as a Constraint and it's
     * `isVisible` and `value` values will be used to set a Property for description.
     *
     * @see StringBuilder
     * @param descriptionProperty the `Property` containing the description that this Task's description property
     * will be set to
     * @return this Task after setting the Task's description Property
     */
    fun setDescriptionProperty(descriptionProperty: Property<Description>): Task {
        this.description = Property(descriptionProperty.isVisible, descriptionProperty.value)
        update()
        return this
    }

    /**
     * Sets this Task's description Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setDescriptionProperty(Property(SHOWING, myDescription))`.
     *
     * @see Task.setDescriptionProperty
     * @param description the description that this Task's description Property will be set to
     * @return this Task after setting the Task's description Property
     */
    fun setDescriptionValue(description: Description) = setDescriptionProperty(Property(SHOWING, description))

    //endregion Description

    //region Checklist

    /**
     * Sets this Task's checklist Property, the passed in Property can be a Constraint.
     *
     * Further changes will occur only if the passed in `checklistProperty` is a Constraint, otherwise no more changes
     * will occur.
     *
     * In the case that the passed in `checklistProperty` is a Constraint, two things will happen:
     *
     * * This Task will become failable if it wasn't already
     * * This Task will start viewing the checklist to see if all its list items are checked, if they are, the checklist
     * Constraint is met, see [checklistConstraintChecking]
     *
     * Note: An empty checklist means every item in the checklist is checked so this can make the checklist
     * Constraint met
     *
     * If the passed in `checklistProperty` is not a Constraint then the Task's state will remain the same.
     *
     * @see Task.checklistConstraintChecking
     * @see Checklist
     * @param checklistProperty the `Property` of type `Checklist` that this Task's checklist will be set to
     * @return this Task after setting the Task's checklist Property
     */
    fun setChecklistProperty(checklistProperty: Property<Checklist>): Task {
        this.checklist = checklistProperty
        if (checklistProperty is Constraint) {
            makeFailableIfConstraint(checklistProperty)
            checklistConstraintChecking()
        }
        update()
        return this
    }

    /**
     * Sets this Task's checklist Constraint.
     *
     * @see Task.setChecklistProperty
     * @param checklistConstraint the `Constraint` of type `Checklist` that this Task's checklist will be set to
     * @return this Task after setting the Task's checklist Constraint
     */
    fun setChecklistConstraint(checklistConstraint: Constraint<Checklist>) = setChecklistProperty(checklistConstraint)

    /**
     * Sets this Task's checklist Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setChecklistProperty(Property(SHOWING, myChecklist))`.
     *
     * @see Task.setChecklistProperty
     * @param checklist the Checklist value that this Task's checklist value will be set to
     * @return this Task after setting the Task's checklist Property
     */
    fun setChecklistPropertyValue(checklist: Checklist) = setChecklistProperty(Property(SHOWING, checklist))

    /**
     * Sets this Task's checklist Constraint with the given value and makes the Constraint showing and unmet.
     *
     * This is a shorthand of writing `setChecklistConstraint(Constraint(SHOWING, myChecklist, UNMET))`.
     *
     * @see Task.setChecklistProperty
     * @param checklist the Checklist value that this Task's checklist value will be set to
     * @return this Task after setting the Task's checklist Constraint
     */
    fun setChecklistConstraintValue(checklist: Checklist) = setChecklistProperty(Constraint(SHOWING, checklist, UNMET))

    //endregion Checklist

    //region Deadline

    /**
     * Sets this Task's deadline Property, the passed in Property can be a Constraint.
     *
     * Further changes will occur only if the passed in `deadlineProperty` is a Constraint.
     *
     * In the case that the passed in `deadlineProperty` is a Constraint, three things will happen:
     *
     * * The deadline Constraint will become met until that deadline time where it will become unmet again, this is
     * only in the case that the Task is not killed before the deadline, this is done in order to allow the Task to
     * be killed
     * * This Task will become failable if it wasn't already
     * * This Task will start checking the time to compare it with the deadline, if the current time is after the
     * deadline plus the defined grace period [GRACE_PERIOD] then the Task becomes failed and the deadline Constraint
     * becomes unmet. See [deadlineConstraintChecking].
     *
     * If the passed in `deadlineProperty` is not a Constraint then there will be no further changes and the Task
     * will not fail automatically.
     *
     * @see Task.deadlineConstraintChecking
     * @param deadlineProperty the `Property` of type `java.time.Time` that this Task's deadline will be set to
     * @return this Task after setting the Task's deadline Property
     */
    fun setDeadlineProperty(deadlineProperty: Property<Time>): Task {
        this.deadline = deadlineProperty
        if (deadlineProperty is Constraint) {
            makeFailableIfConstraint(deadlineProperty)
            deadlineConstraintChecking()
        }
        update()
        return this
    }

    /**
     * Gets the duration left until this Task's deadline will occur, this ignores the grace period.
     *
     * @return the Duration left until this Task's deadline occurs, ignores the grace period
     * @throws TaskException if the deadline has not been set
     */
    fun getTimeUntilDeadline(): Duration {
        if (deadline.value == DEFAULT_DEADLINE) {
            throw TaskException("Deadline not set!")
        } else {
            return Duration.between(now, this.deadline.value)
        }
    }

    /**
     * Sets this Task's deadline Constraint.
     *
     * @see Task.setDeadlineProperty
     * @param deadlineConstraint the `Constraint` of type `java.time.Time` that this Task's deadline will be
     * set to
     * @return this Task after setting the Task's deadline Constraint
     */
    fun setDeadlineConstraint(deadlineConstraint: Constraint<Time>) = setDeadlineProperty(deadlineConstraint)

    /**
     * Sets this Task's deadline Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setDeadlineProperty(Property(SHOWING, myDeadline))`.
     *
     * @see Task.setDeadlineProperty
     * @param deadline the java.time.Time value that this Task's deadline value will be set to
     * @return this Task after setting the Task's deadline Property
     */
    fun setDeadlinePropertyValue(deadline: Time) = setDeadlineProperty(Property(SHOWING, deadline))

    /**
     * Sets this Task's deadline Constraint with the given value and makes the Constraint showing and unmet.
     *
     * This is a shorthand of writing `setDeadlineConstraint(Constraint(SHOWING, myDeadline, UNMET))`.
     *
     * @see Task.setDeadlineProperty
     * @param deadline the java.time.Time value that this Task's deadline value will be set to
     * @return this Task after setting the Task's deadline Constraint
     */
    fun setDeadlineConstraintValue(deadline: Time) = setDeadlineProperty(Constraint(SHOWING, deadline, UNMET))

    //endregion Deadline

    //region Target

    /**
     * Sets this Task's target Property, the passed in Property can be a Constraint.
     *
     * If the passed in `targetProperty` is a Constraint then this Task will become failable if it wasn't already.
     *
     * @see Target
     * @param targetProperty the `Property` of type `Target` that this Task's target will be set to
     * @return this Task after setting the Task's target Property
     */
    fun setTargetProperty(targetProperty: Property<Target>): Task {
        this.target = targetProperty
        makeFailableIfConstraint(targetProperty)
        update()
        return this
    }

    /**
     * Sets this Task's target Constraint.
     *
     * @see Task.setTargetProperty
     * @param targetConstraint the `Constraint` of type `Target` that this Task's target will be set to
     * @return this Task after setting the Task's target Constraint
     */
    fun setTargetConstraint(targetConstraint: Constraint<Target>) = setTargetProperty(targetConstraint)

    /**
     * Sets this Task's target Property with the given value and makes the Property showing.
     *
     * This is a shorthand of writing `setTargetProperty(Property(SHOWING, myTarget))`.
     *
     * @see Task.setTargetProperty
     * @param target the Target value that this Task's target value will be set to
     * @return this Task after setting the Task's target Property
     */
    fun setTargetPropertyValue(target: Target) = setTargetProperty(Property(SHOWING, target))

    /**
     * Sets this Task's target Constraint with the given value and makes the Constraint showing and unmet.
     *
     * This is a shorthand of writing `setTargetConstraint(Constraint(SHOWING, myTarget, UNMET))`.
     *
     * @see Task.setTargetProperty
     * @param target the Target value that this Task's checklist value will be set to
     * @return this Task after setting the Task's checklist Constraint
     */
    fun setTargetConstraintValue(target: Target) = setTargetProperty(Constraint(SHOWING, target, UNMET))

    //endregion Target

    //region Before

    /**
     * Sets this Task's before Property, the passed in Property can be a Constraint.
     *
     * Further changes will occur only if the passed in `beforeProperty` is a Constraint, otherwise no more changes
     * will occur.
     *
     * In the case that the passed in `beforeProperty` is a Constraint, two things will happen:
     *
     * * This Task will become failable if it wasn't already
     * * This Task will start checking the state of task the before value refers to using the database, and will make
     * the before Constraint met only when the before Task is killed, see [beforeConstraintChecking]
     *
     * If the passed in `beforeProperty` is not a Constraint then the Task's state will remain the same.
     *
     * @see Task.beforeConstraintChecking
     * @param beforeProperty the `Property` of type `uk.whitecrescent.waqti.model.task.ID` that this Task's before property will be set to, this is
     * the before Task's uk.whitecrescent.waqti.model.task.ID
     * @return this Task after setting the Task's before Property
     */
    fun setBeforeProperty(beforeProperty: Property<ID>): Task {
        this.before = beforeProperty
        if (beforeProperty is Constraint) {
            makeFailableIfConstraint(beforeProperty)
            beforeConstraintChecking()
        }
        update()
        return this
    }

    /**
     * Sets this Task's before Constraint.
     *
     * @see Task.setBeforeProperty
     * @param beforeConstraint the `Constraint` of type `uk.whitecrescent.waqti.model.task.ID` that this Task's before will be set to
     * @return this Task after setting the Task's before Constraint
     */
    fun setBeforeConstraint(beforeConstraint: Constraint<ID>) = setBeforeProperty(beforeConstraint)

    /**
     * Sets this Task's before Property with the given uk.whitecrescent.waqti.model.task.ID value and makes the Property showing.
     *
     * This is a shorthand of writing `setBeforeProperty(Property(SHOWING, myBefore))`.
     *
     * @see Task.setBeforeProperty
     * @param beforeuk.whitecrescent.waqti.task.ID the uk.whitecrescent.waqti.model.task.ID of the Task that is before this one that this Task's before value will be set to
     * @return this Task after setting the Task's before Property
     */
    fun setBeforePropertyValue(beforeID: ID) = setBeforeProperty(Property(SHOWING, beforeID))

    /**
     * Sets this Task's before Constraint with the given uk.whitecrescent.waqti.model.task.ID value and makes the Constraint showing and unmet.
     *
     * This is a shorthand of writing `setBeforeConstraint(Constraint(SHOWING, myBefore, UNMET))`.
     *
     * @see Task.setBeforeProperty
     * @param beforeuk.whitecrescent.waqti.task.ID the uk.whitecrescent.waqti.model.task.ID of the Task that is before this one that this Task's before value will be set to
     * @return this Task after setting the Task's before Constraint
     */
    fun setBeforeConstraintValue(beforeID: ID) = setBeforeProperty(Constraint(SHOWING, beforeID, UNMET))

    /**
     * Sets this Task's before Property with the given Task value and makes the Property showing.
     *
     * This is a shorthand of writing `setBeforeProperty(Property(SHOWING, myBefore))`.
     *
     * @see Task.setBeforeProperty
     * @param beforeTask the Task that is before this one that this Task's before value will be set to
     * @return this Task after setting the Task's before Property
     */
    fun setBeforePropertyValue(beforeTask: Task) = setBeforeProperty(Property(SHOWING, beforeTask.id))

    /**
     * Sets this Task's before Constraint with the given Task value and makes the Constraint showing and unmet.
     *
     * This is a shorthand of writing `setBeforeConstraint(Constraint(SHOWING, myBefore, UNMET))`.
     *
     * @see Task.setBeforeProperty
     * @param beforeTask the Task that is before this one that this Task's before value will be set to
     * @return this Task after setting the Task's before Constraint
     */
    fun setBeforeConstraintValue(beforeTask: Task) = setBeforeProperty(Constraint(SHOWING, beforeTask.id, UNMET))

    //endregion Before

    //region SubTasks

    /**
     * Sets this Task's sub-Tasks Property, the passed in Property can be a Constraint.
     *
     * Further changes will occur only if the passed in `subTasksProperty` is a Constraint, otherwise no more changes
     * will occur.
     *
     * In the case that the passed in `subTasksProperty` is a Constraint, two things will happen:
     *
     * * This Task will become failable if it wasn't already
     * * This Task will start checking the state of all of its sub-Tasks, if all are KILLED then the sub-Tasks
     * Constraint is met, if any one sub-Task is FAILED then this Task is FAILED if it is failable, see [subTasksConstraintChecking]
     *
     * If the passed in `subTasksProperty` is not a Constraint then the Task's state will remain the same.
     *
     * @see Task.subTasksConstraintChecking
     * @param subTasksProperty the `Property` of type `ArrayList<uk.whitecrescent.waqti.model.task.ID>` that this Task's subTasks property will be
     * set to, this is the list of uk.whitecrescent.waqti.task.IDs of the sub-Tasks
     * @return this Task after setting the Task's subTasks Property
     */
    fun setSubTasksProperty(subTasksProperty: Property<ArrayList<ID>>): Task {
        this.subTasks = subTasksProperty
        if (subTasksProperty is Constraint) {
            makeFailableIfConstraint(subTasksProperty)
            subTasksConstraintChecking()
        }
        update()
        return this
    }

    /**
     * Sets this Task's subTasks Constraint.
     *
     * @see Task.setSubTasksProperty
     * @param subTasksConstraint the `Constraint` of type `ArrayList<uk.whitecrescent.waqti.model.task.ID>` that this Task's subTasks will be set to
     * @return this Task after setting the Task's subTasks Constraint
     */
    fun setSubTasksConstraint(subTasksConstraint: Constraint<ArrayList<ID>>) = setSubTasksProperty(subTasksConstraint)

    /**
     * Sets this Task's subTasks Property with the given ArrayList of uk.whitecrescent.waqti.task.IDs and makes the Property showing.
     *
     * This is a shorthand of writing `setSubTasksProperty(Property(SHOWING, mySubTasks))`.
     *
     * @see Task.setSubTasksProperty
     * @param subTasks the ArrayList of uk.whitecrescent.waqti.task.IDs of the subTasks that this Task's subTasks value will be set to
     * @return this Task after setting the Task's subTasks Property
     */
    fun setSubTasksPropertyValue(subTasks: ArrayList<ID>) = setSubTasksProperty(Property(SHOWING, subTasks))

    /**
     * Sets this Task's subTasks Constraint with the given ArrayList of uk.whitecrescent.waqti.task.IDs and makes the Constraint showing and
     * unmet.
     *
     * This is a shorthand of writing `setSubTasksConstraint(Constraint(SHOWING, mySubTasks, UNMET))`.
     *
     * @see Task.setSubTasksProperty
     * @param subTasks he ArrayList of uk.whitecrescent.waqti.task.IDs of the subTasks that this Task's subTasks value will be set to
     * @return this Task after setting the Task's subTasks Constraint
     */
    fun setSubTasksConstraintValue(subTasks: ArrayList<ID>) = setSubTasksProperty(Constraint(SHOWING, subTasks, UNMET))

    /**
     * Adds the given subTasks to this Task's subTasks Property and makes this Task's subTasks Property showing if it
     * wasn't already.
     *
     * @param tasks the Tasks to add to this Task's subTasks Property
     * @return this Task after adding the given subTasks to the Task's subTasks Property
     */
    fun addSubTasks(vararg tasks: Task): Task {
        setSubTasksProperty(
                Property(SHOWING,
                        ArrayList(this.subTasks.value + tasks.toList().ids))
        )
        return this
    }

    fun addSubTasksConstraint(vararg tasks: Task): Task {
        val value = this.subTasks.value
        val list = ArrayList<Task>()
        list.addAll(tasks)
        value.addAll(list.ids)
        setSubTasksProperty(Constraint(SHOWING, value, UNMET))
        return this
    }

    /**
     * Gets the ArrayList of uk.whitecrescent.waqti.task.IDs of the sub-Tasks of this Task
     *
     * @return the ArrayList of uk.whitecrescent.waqti.task.IDs of the sub-Tasks of this Task
     */
    fun getSubTasksIDsList(): ArrayList<ID> {
        return this.subTasks.value
    }

    /**
     * Gets the ArrayList of Tasks of the sub-Tasks of this Task
     *
     * @return the ArrayList of Tasks of the sub-Tasks of this Task
     */
    fun getSubTasksList(): List<Task> {
        return ArrayList(this.subTasks.value.tasks).toList()
    }

    /**
     * Gets the maximum depth of sub-Tasks of this Task, this is a recursive function
     *
     * @return the maximum depth of sub-Tasks of this Task
     */
    fun getSubTasksLevelsDepth(task: Task = this): Int {
        val list = arrayListOf<Int>()
        return if (task.subTasks.value.isEmpty()) {
            0
        } else {
            for (task0 in task.subTasks.value.tasks) {
                list.add(getSubTasksLevelsDepth(task0) + 1)
            }
            list.max()!!
        }
    }

    //endregion SubTasks

    //endregion Property setters for chaining

    //region Hide Properties

    fun hideTime() {
        if (time.isNotConstraint) {
            time = DEFAULT_TIME_PROPERTY
            update()
        } else throw TaskException("Cannot hide, time is Constraint")
    }

    fun hideDuration() {
        if (duration.isNotConstraint) {
            duration = DEFAULT_DURATION_PROPERTY
            update()
        } else throw TaskException("Cannot hide, duration is Constraint")
    }

    fun hidePriority() {
        if (priority.isNotConstraint) {
            priority = DEFAULT_PRIORITY_PROPERTY
            update()
        } else throw TaskException("Cannot hide, priority is Constraint")
    }

    fun hideLabel() {
        if (labels.isNotConstraint) {
            labels = DEFAULT_LABELS_PROPERTY
            update()
        } else throw TaskException("Cannot hide, labels is Constraint")
    }

    fun hideOptional() {
        if (optional.isNotConstraint) {
            optional = DEFAULT_OPTIONAL_PROPERTY
            update()
        } else throw TaskException("Cannot hide, optional is Constraint")
    }

    fun hideDescription() {
        if (description.isNotConstraint) {
            description = DEFAULT_DESCRIPTION_PROPERTY
            update()
        } else throw TaskException("Cannot hide, description is Constraint")
    }

    fun hideChecklist() {
        if (checklist.isNotConstraint) {
            checklist = DEFAULT_CHECKLIST_PROPERTY
            update()
        } else throw TaskException("Cannot hide, checklist is Constraint")
    }

    fun hideDeadline() {
        if (deadline.isNotConstraint) {
            deadline = DEFAULT_DEADLINE_PROPERTY
            update()
        } else throw TaskException("Cannot hide, deadline is Constraint")
    }

    fun hideTarget() {
        if (target.isNotConstraint) {
            target = DEFAULT_TARGET_PROPERTY
            update()
        } else throw TaskException("Cannot hide, target is Constraint")
    }

    fun hideBefore() {
        if (before.isNotConstraint) {
            before = DEFAULT_BEFORE_PROPERTY
            update()
        } else throw TaskException("Cannot hide, before is Constraint")
    }

    fun hideSubTasks() {
        if (subTasks.isNotConstraint) {
            subTasks = DEFAULT_SUB_TASKS_PROPERTY
            update()
        } else throw TaskException("Cannot hide, subTasks is Constraint")
    }

    //endregion Hide Properties

    //region Task lifecycle

    override fun update() {
        Caches.tasks.put(this)
    }

    fun canKill() = isKillable &&
            this.state == TaskState.EXISTING &&
            getAllUnmetAndShowingConstraints().isEmpty()

    fun canFail() = isFailable &&
            this.state == TaskState.EXISTING

    fun canSleep() = this.state == TaskState.FAILED ||
            this.state == TaskState.EXISTING

    fun fail() {
        if (!isFailable) {
            throw TaskStateException("Fail unsuccessful, ${this.title} is not Failable", this.state)
        }
        if (state == TaskState.FAILED) {
            throw TaskStateException("Fail unsuccessful, ${this.title} is already Failed!", this.state)
        }
        if (state == TaskState.SLEEPING) {
            throw TaskStateException("Fail unsuccessful, ${this.title} is Sleeping!", this.state)
        }
        if (state == TaskState.KILLED) {
            throw TaskStateException("Fail unsuccessful, ${this.title} is Killed!", this.state)
        } else if (canFail()) {
            state = TaskState.FAILED
            age++
            failedTimes.add(now)
            update()
        } else {
            throw TaskStateException("Fail unsuccessful, unknown reason, remember only EXISTING tasks can be " +
                    "failed!", this.state)
        }
    }

    fun sleep() {
        if (state == TaskState.SLEEPING) {
            throw TaskStateException("Sleep unsuccessful, ${this.title} is already Sleeping!", this.state)
        }
        if (state == TaskState.KILLED) {
            throw TaskStateException("Sleep unsuccessful, ${this.title} is Killed!", this.state)
        } else if (canSleep()) {
            state = TaskState.SLEEPING
            update()
        } else {
            throw TaskStateException(
                    "Sleep unsuccessful, unknown reason, remember only FAILED or EXISTING tasks can be Slept!",
                    this.state)
        }
    }

    fun kill() {
        if (!isKillable) {
            throw TaskStateException("Kill unsuccessful, ${this.title} is not Killable", this.state)
        }
        if (state == TaskState.KILLED) {
            throw TaskStateException("Kill unsuccessful, ${this.title} is already Killed!", this.state)
        }
        if (state == TaskState.FAILED) {
            throw TaskStateException("Kill unsuccessful, ${this.title} is Failed", this.state)
        }
        if (state == TaskState.SLEEPING) {
            throw TaskStateException("Kill unsuccessful, ${this.title} is Sleeping", this.state)
        }
        if (getAllUnmetAndShowingConstraints().isNotEmpty()) {
            throw TaskStateException(
                    "Kill unsuccessful, ${this.title} has unmet Constraints ${this.getAllUnmetAndShowingConstraints()}",
                    this.state)
        } else if (canKill()) {
            state = TaskState.KILLED
            killedTime = now
            endObservers() // TODO: 02-May-18 It's safe to do this since the lifecycle can no longer change, properties still can tho
            update()
        } else {
            throw TaskStateException(
                    "Kill unsuccessful, unknown reason, remember only EXISTING tasks can be killed!",
                    this.state)
        }
    }

    //endregion Task lifecycle

    //region Timer

    // Timer is independent of Duration Constraint, but Duration Constraint needs the timer to run to be MET

    fun startTimer(): Task {
        if (state != TaskState.EXISTING) {
            throw TaskStateException("Task must be EXISTING to start Timer!", state)
        } else {
            timer.start()
            if (duration is Constraint) {
                durationConstraintTimerChecking()
            }
        }
        return this
    }

    fun pauseTimer(): Task {
        timer.pause()
        return this
    }

    fun stopTimer(): Task {
        timer.stop()
        return this
    }

    fun timerDuration() = timer.duration

    fun timerIsRunning() = timer.running

    fun timerIsPaused() = timer.paused

    fun timerIsStopped() = timer.stopped

    //endregion Timers

    //region Observers

    /*
     * Pick one implementation to avoid memory leaks, either we have an in memory database, in which case we check if
     * this task is in it, if it's not then it implies this task is no longer used meaning lets kill all its
     * observers or we just call a finalizing method when we know this task will no longer be used, I don't think
     * both can work together but I could be wrong, the first one though may be very memory expensive, or not, we
     * have to really test this per platform, it might actually not be memory expensive, or at least its a necessary
     * expense because we can use the in memory database to access tasks very quickly, thus making the in memory
     * database a sort of buffer between the persistent database and the live runtime
     */
    private fun checkNotDead() {
        var done = false
        Observable.interval(100L, java.util.concurrent.TimeUnit.MILLISECONDS)
                // TODO: 18-Jun-18 problems here too, also check a suitable interval
                .takeWhile { !done }
                .subscribeOn(Schedulers.computation())
                .subscribe(
                        {
                            if (this !in Caches.tasks) {
                                endObservers()
                                done = true
                            }
                        },
                        {
                            throw ObserverException("Checking Not Dead Failed!")
                        }
                )
    }

    // Can't restart them (not that I know of). dangerous!
    // Lifecycle will not happen automatically if there are no observers checking, even when it should
    private fun endObservers() = composite.clear()

    /**
     * Checks the time on the `stateCheckingThread` to match it with this Task's time Constraint value.
     *
     * When the time is past this Task's time Constraint value the state will change to EXISTING and the time
     * Constraint will be met if it wasn't already and the checking ends.
     *
     * If this Task's time is no longer a Constraint (time is un-constrained) then the changes
     * [setTimeProperty] will be undone, namely:
     *
     * * This Task's state will become EXISTING
     * * This Task will become non-failable if there are no Constraints
     * * The time checking will end
     *
     * If the time Constraint is re-set, set to a new value, then this Observer ends and a new one begins checking the
     * new value.
     *
     * The Observer performs this check every [TIME_CHECKING_PERIOD] [TIME_CHECKING_UNIT], see Constants for these
     * values as they may change for performance reasons.
     *
     * This function is only called when `time` is set as a Constraint and the time value is in the future.
     *
     * This has been tested to be computationally cheap when running for 1000 tasks concurrently since the checking
     * is done once every so often, which itself is cheap.
     *
     * @see Task.setTimeProperty
     * @throws ObserverException if the Observer's `onError` is called for any reasons
     */
    private fun timeConstraintTimeChecking() {
        val originalValue = this.time.value
        var done = false

        val disposable = Observable.interval(TIME_CHECKING_PERIOD, TIME_CHECKING_UNIT)
                .takeWhile { !done }
                .doOnComplete { update() }
                .subscribeOn(TIME_CONSTRAINT_THREAD)
                .subscribe(
                        {
                            when {
                                this.time !is Constraint -> {
                                    makeNonFailableIfNoConstraints()
                                    if (this.state == TaskState.SLEEPING) this.state = TaskState.EXISTING
                                    done = true
                                }
                                this.time.value != originalValue -> {
                                    done = true
                                }
                                now.isAfter(this.time.value) -> {
                                    if (this.state == TaskState.SLEEPING) this.state = TaskState.EXISTING
                                    if (this.time is Constraint && (this.time as Constraint).isMet != MET) {
                                        (this.time as Constraint).isMet = MET
                                    }
                                    done = true
                                }
                            }
                        },
                        {
                            throw ObserverException("Time Constraint time checking failed!")
                        }
                )
        composite.add(disposable)
    }

    /**
     * Checks the time that this Task's duration will end on the `stateCheckingThread` to match it with this Task's
     * duration Constraint value
     *
     * When the time is past this Task's duration Constraint value the duration Constraint will be met if it wasn't
     * already and the checking ends.
     *
     * If this Task's duration is no longer a Constraint (duration is un-constrained) then the changes
     * [setDurationProperty] will be undone, namely:
     *
     * * This Task will become non-failable if there are no Constraints
     * * The duration checking will end
     *
     * If the duration Constraint is re-set, set to a new value, then this Observer ends and a new one begins checking
     * the new value.
     *
     * The Observer performs this check every [TIME_CHECKING_PERIOD] [TIME_CHECKING_UNIT], see Constants for these
     * values as they may change for performance reasons.
     *
     * This function is only called when `duration` is set as a Constraint.
     *
     * This has been tested to be computationally cheap when running for 1000 tasks concurrently since the checking
     * is done once every so often, which itself is cheap.
     *
     * @see Task.setTimeProperty
     * @throws ObserverException if the Observer's `onError` is called for any reasons
     */
    private fun durationConstraintTimerChecking() {
        val originalValue = this.duration.value
        var done = false

        val disposable = Observable.interval(TIME_CHECKING_PERIOD, TIME_CHECKING_UNIT)
                .takeWhile { !done }
                .doOnComplete { update() }
                .subscribeOn(DURATION_CONSTRAINT_THREAD)
                .subscribe(
                        {
                            when {
                                this.duration !is Constraint -> {
                                    makeNonFailableIfNoConstraints()
                                    done = true
                                }
                                this.duration.value != originalValue -> {
                                    done = true
                                }
                                this.timer.stopped -> {
                                    done = true
                                }
                                timer.duration >= this.duration.value -> {
                                    if (this.duration is Constraint && !(this.duration as Constraint).isMet) {
                                        (this.duration as Constraint).isMet = MET
                                    }
                                    done = true
                                }
                            }
                        },
                        {
                            throw ObserverException("Duration Constraint timer checking failed!")
                        }
                )
        composite.add(disposable)
    }

    /**
     * Checks this Task's checklist Property value (the actual checklist) on the `stateCheckingThread` to see if all
     * its list items are checked or not.
     *
     * When the checklist has no unchecked items this Task's checklist Constraint will be met if it wasn't already
     * and the checking ends.
     *
     * If this Task's checklist is no longer a Constraint (checklist is un-constrained) then the changes
     * [setChecklistProperty] will be undone, namely:
     *
     * * This Task will become non-failable if there are no Constraints
     * * The checklist checking will end
     *
     * If the checklist Constraint is re-set, set to a new value, then this Observer ends and a new one begins checking
     * the new value.
     *
     * The Observer performs this check every [TIME_CHECKING_PERIOD] [TIME_CHECKING_UNIT], see Constants for these
     * values as they may change for performance reasons.
     *
     * This function is only called when `checklist` is set as a Constraint.
     *
     * @see Task.setChecklistProperty
     * @throws ObserverException if the Observer's `onError` is called for any reasons
     */
    private fun checklistConstraintChecking() {
        val originalValue = this.checklist.value
        var done = false

        val disposable = Observable.interval(TIME_CHECKING_PERIOD, TIME_CHECKING_UNIT)
                .takeWhile { !done }
                .doOnComplete { update() }
                .subscribeOn(CHECKLIST_CONSTRAINT_THREAD)
                .subscribe(
                        {
                            when {
                                this.checklist !is Constraint -> {
                                    makeNonFailableIfNoConstraints()
                                    done = true
                                }
                                this.checklist.value != originalValue -> {
                                    done = true
                                }
                                this.checklist.value.getAllUncheckedItems().isEmpty() -> {
                                    if (this.checklist is Constraint && (this.checklist as Constraint).isMet != MET) {
                                        (this.checklist as Constraint).isMet = MET
                                    }
                                    done = true
                                }
                            }
                        },
                        {
                            throw ObserverException("Checklist Constraint checking failed")
                        }
                )

        composite.add(disposable)
    }

    /**
     * Checks the time on the `stateCheckingThread` to match it with this Task's deadline Constraint value plus the
     * grace period [GRACE_PERIOD].
     *
     * When the time is past this Task's deadline Constraint value plus the grace period, the state will change to
     * FAILED and the deadline Constraint will be unmet and the checking ends.
     *
     * If this Task's deadline is no longer a Constraint (deadline is un-constrained) then the changes
     * [setDeadlineProperty] will be undone, namely:
     *
     * * This Task will become non-failable if there are no Constraints
     * * The deadline checking will end
     *
     * If the checklist Constraint is re-set, set to a new value, then this Observer ends and a new one begins checking
     * the new value.
     *
     * The Observer performs this check every [TIME_CHECKING_PERIOD] [TIME_CHECKING_UNIT], see Constants for these
     * values as they may change for performance reasons.
     *
     * This function is only called when `deadline` is set as a Constraint.
     *
     * This has been tested to be computationally cheap when running for 1000 tasks concurrently since the checking
     * is done once every so often, which itself is cheap.
     *
     * @see Task.setDeadlineProperty
     * @throws ObserverException if the Observer's `onError` is called for any reasons
     */
    private fun deadlineConstraintChecking() {
        var done = false
        val originalValue = this.deadline.value
        val deadlineWithGrace = this.deadline.value.plus(GRACE_PERIOD)

        val disposable = Observable.interval(TIME_CHECKING_PERIOD, TIME_CHECKING_UNIT)
                .takeWhile { !done }
                .doOnSubscribe { (deadline as Constraint).isMet = true }
                .doOnComplete { update() }
                .subscribeOn(DEADLINE_CONSTRAINT_THREAD)
                .subscribe(
                        {
                            when {
                                this.deadline !is Constraint -> {
                                    makeNonFailableIfNoConstraints()
                                    done = true
                                }
                                this.deadline.value != originalValue -> {
                                    done = true
                                }
                                now.isAfter(deadlineWithGrace) -> {
                                    if (canFail()) {
                                        this.fail()
                                        (deadline as Constraint).isMet = false
                                    }
                                    done = true
                                }
                            }
                        },
                        {
                            throw ObserverException("Deadline Constraint checking failed!")
                        }
                )
        composite.add(disposable)

    }

    /**
     * Checks the state of the Task before this one on the `otherTaskCheckingThread`. If it is failed then this Task
     * will fail if it can, if it is killed then the before Constraint is met.
     *
     * If the before Task's state is FAILED then this Task will fail if it can [canFail].
     *
     * If the before Task's state is KILLED then this Task's before Constraint will be met.
     *
     * If this Task's before is no longer a Constraint (before is un-constrained) then the changes
     * [setBeforeProperty] will be undone, namely:
     *
     * * This Task will become non-failable if there are no Constraints
     * * The before checking will end
     *
     * If the before Constraint is re-set, set to a new value, then this Observer ends and a new one begins checking
     * the new value.
     *
     * The Observer performs this check every [TIME_CHECKING_PERIOD] [TIME_CHECKING_UNIT], see Constants for these
     * values as they may change for performance reasons.
     *
     * This function is only called when `before` is set as a Constraint.
     *
     * This has been tested to be computationally cheap when running for 1000 tasks concurrently since the checking
     * is done once every so often, which itself is cheap.
     *
     * @see Task.setBeforeProperty
     * @throws ObserverException if the Observer's `onError` is called for any reasons or if the before Task cannot
     * be found in the database
     */
    private fun beforeConstraintChecking() {
        var done = false
        val originalValue = this.before.value
        val beforeTask = Caches.tasks.get(this.before.value)

        val disposable = Observable.interval(TIME_CHECKING_PERIOD, TIME_CHECKING_UNIT)
                .takeWhile { !done }
                .doOnComplete { update() }
                .subscribeOn(BEFORE_CONSTRAINT_THREAD)
                .subscribe(
                        {
                            when {
                                !Caches.tasks.contains(beforeTask) -> {
                                    throw ObserverException("Before Constraint checking failed!" +
                                            " Before is null in database")
                                }
                                this.before !is Constraint -> {
                                    makeNonFailableIfNoConstraints()
                                    done = true
                                }
                                this.before.value != originalValue -> {
                                    done = true
                                }
                                beforeTask.state == TaskState.KILLED -> {
                                    (this.before as Constraint).isMet = true
                                    done = true
                                }
                                beforeTask.state == TaskState.FAILED -> {
                                    (this.before as Constraint).isMet = false
                                    if (canFail()) fail()
                                    done = true
                                }

                            }
                        },
                        {
                            throw ObserverException("Before Constraint checking failed!")
                        }
                )
        composite.add(disposable)
    }

    /**
     * Checks the state of the sub-Tasks of this Task on the `otherTaskCheckingThread`.
     *
     * If any of the sub-Tasks' states is FAILED then this Task will fail if it can [canFail].
     *
     * If all of the sub-Tasks' states is KILLED then this Task's subTasks Constraint will be met.
     *
     * If this Task's subTasks is no longer a Constraint (subTasks is un-constrained) then the changes
     * [setSubTasksProperty] will be undone, namely:
     *
     * * This Task will become non-failable if there are no Constraints
     * * The subTasks checking will end
     *
     * If the subTasks Constraint is re-set, set to a new value, then this Observer ends and a new one begins checking
     * the new value.
     *
     * The Observer performs this check every [TIME_CHECKING_PERIOD] [TIME_CHECKING_UNIT], see Constants for these
     * values as they may change for performance reasons.
     *
     * This function is only called when `subTasks` is set as a Constraint.
     *
     * This has been tested to be computationally cheap when running for 1000 tasks concurrently since the checking
     * is done once every so often, which itself is cheap.
     *
     * @see Task.setSubTasksProperty
     * @throws ObserverException if the Observer's `onError` is called for any reasons
     */
    private fun subTasksConstraintChecking() {
        val originalValue = this.subTasks.value
        var done = false

        val disposable = Observable.interval(TIME_CHECKING_PERIOD, TIME_CHECKING_UNIT)
                .takeWhile { !done }
                .doOnComplete { update() }
                .subscribeOn(SUB_TASKS_CONSTRAINT_THREAD)
                .subscribe(
                        {
                            when {
                            // TODO: 18-Jun-18 problems here when running SubTasks tests,
                                !Caches.tasks.containsAll(this.subTasks.value.tasks) -> {
                                    throw ObserverException("SubTasks Constraint checking failed!" +
                                            " Some SubTask is null in database")
                                }
                                this.subTasks !is Constraint -> {
                                    makeNonFailableIfNoConstraints()
                                    done = true
                                }
                                this.subTasks.value != originalValue -> {
                                    done = true
                                }
                            // SubTasks contains more than 0 failed Tasks
                                this.subTasks.value.tasks.any { it.state == TaskState.FAILED } -> {
                                    (subTasks as Constraint).isMet = false
                                    if (canFail()) fail()
                                    done = true
                                }
                            // All SubTasks are killed
                                this.subTasks.value.tasks
                                        .all { it.state == TaskState.KILLED } -> {
                                    (subTasks as Constraint).isMet = true
                                    done = true
                                }

                            }
                        },
                        {
                            //println(this.id)
                            //println(this in Caches.tasks)
                            //it.printStackTrace()
                            //throw ObserverException("SubTasks Constraint checking failed!")
                        }
                )

        composite.add(disposable)
    }

    //endregion Observers

    //region Overriden

    /**
     * Returns the hash code of this Task, this is the hash code of this Task's equalityBundle, see [equalityBundle]
     *
     * @see java.util.AbstractMap.hashCode
     * @see Any.hashCode
     * @return the hash code of this Task
     */
    override fun hashCode() = equalityBundle().hashCode()

    /**
     * Checks whether the given `other` is equal to this Task or not, if `other` is not a Task then returns false, then
     * determines that the Tasks are equal if and only if their bundles are equal [equalityBundle]
     *
     * @see Task.equalityBundle
     * @see Any.equals
     * @return true if `other` is a Task and its equalityBundle is equal to this Task's equalityBundle, false otherwise
     */
    override fun equals(other: Any?) =
            other is Task && other.equalityBundle() == this.equalityBundle()

    /**
     * Returns the String representation of this Task, depicted using Task Card syntax which appears as follows:
     * ```
     * "My Task"
     * ID: 123456789 isKillable: true isFailable: false state: EXISTING
     *     P:
     *         ...
     *     C:
     *         ...
     * ```
     *
     * The Properties and Constraints are represented using their toString function. [Property.toString] [Constraint.toString]
     *
     * @see Any.toString
     * @return the String representation of this Task
     */
    override fun toString(): String {
        val result = StringBuilder("$title\n")
        result.append("ID: $id isKillable: $isKillable isFailable: $isFailable state: $state\n")

        result.append("\tP:\n")
        getAllShowingProperties().filter { it !is Constraint }.forEach { result.append("\t\t$it\n") }

        result.append("\tC:\n")
        getAllShowingConstraints().forEach { result.append("\t\t$it\n") }

        return result.toString()
    }

    //endregion Overriden

    //region Template Task

    fun toTemplate() = Template(this)

    companion object {
        fun fromTemplate(template: Template) = Template.fromTemplate(template)

        fun taskBundlesAreSubset(superTask: Task, subTask: Task) =
                PropertyBundle.bundlesAreSubset(PropertyBundle(superTask), PropertyBundle(subTask))
    }

    //endregion Template Task
}